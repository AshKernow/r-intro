---
title: "Introduction to Solving Biological Problems Using R - Day 2"
author: Mark Dunning and Aiora Zabala. Original material by Robert Stojnić, Laurent Gatto, Rob Foy
  John Davey, Dávid Molnár and Ian Roberts
date: '`r format(Sys.time(), "Last modified: %d %b %Y")`'
output: slidy_presentation
toc: yes
---

## Day 2 Schedule

1. Further customisation of plots
2. Statistics
3. Report-writing
4. Data Manipulation Techniques

#1. Further customisation of plots

## Recap

- we have seen how to use `plot`, `boxplot` `hist` to make simple plots
- these come with arguments that can be used to change the appearance of the plot
    + `col`, `pch`
    + `main`, `xlab`, `ylab`
    + etc....
- we will now look at ways to modify the plot appearance after it has been created
- also, how to export the graphs 
- Set your working directory to ***Day_2_scripts***


## The painter's model

- R employs a painter's model to construct it's plots
- Elements of the graph are added to the canvas one layer at a time, and the picture built up in levels. Lower levels are obscured by higher levels, allowing for blending, masking and overlaying of objects.

##Initial plot

- Recall our weather dataset from yesterday
    + we might want to display other characteristics on the plot
        + e.g. gender of individual

```{r echo=FALSE}
setwd("Day_2_scripts/")
source("../Day_1_scripts/1.2_patients.R")
```

        
```{r eval=FALSE}
source("../Day_1_scripts/1.2_patients.R")
```

```{r}
plot(patients$Age, patients$Weight,pch=16)
```

##The points function

- `points` can be used to set of points to an *existing* plot
- it requires a vector of x and y coordinates
    + these do not have to be the same length as the number of points in the initial plot
        + hence we can use `points` to highlight observations
        + or add a set of new observations
- Note that axis limits of the existing plot are not altered

```{r}
plot(patients$Age, patients$Weight,pch=16)
points(40,68,pch="X")
```


## Creating a blank plot

- Often it is useful to create a blank 'canvas' with the correct labels and limits

```{r}
plot(patients$Age, patients$Weight,pch=16,type="n")
```

## Adding points to differentiate gender

- Selecting males using the `==` comparison we saw yesterday
    + gives a `TRUE` or `FALSE` value
    + can be used to index the data frame
    + which means we can get the relevant Age and Weight values
```{r}
males <- patients$Sex == "Male"
males
patients[males,]
patients[males,"Age"]
patients[males,"Weight"]
```

## Adding points to differentiate gender

```{r}
plot(patients$Age, patients$Weight,pch=16,type="n")
points(patients$Age[males], patients$Weight[males],pch=16,col="steelblue")

```


## Adding points to differentiate gender


```{r}
females <- patients$Sex == "Female"
females
patients[females,]
```

## Adding points to differentiate gender

```{r}
plot(patients$Age, patients$Weight,pch=16,type="n")
points(patients$Age[males], patients$Weight[males],pch=16,col="steelblue")
points(patients$Age[females], patients$Weight[females],pch=16,col="orangered1")

```


##Adding points

- Each set of points can have a different colour and shape
- Axis labels and title and limits are defined by the plot
- You can add points ad-nauseum. Try not to make the plot cluttered!
- A call to `plot` will start a new graphics window


```{r fig.height=4,fig.width=8}
plot(patients$Age, patients$Weight,pch=16,type="n")
points(patients$Age[males], patients$Weight[males],pch=16,col="steelblue")
points(patients$Age[females], patients$Weight[females],pch=17,col="orangered1")
```



## Adding a legend

- Should also add a legend to help interpret the plot
    + use the `legend` function
    + can give x and y coordinates where legend will appear
    + also recognises shortcuts such as ***topleft*** and ***bottomright***...

```{r fig.height=4,fig.width=8}
plot(patients$Age, patients$Weight,pch=16,type="n")
points(patients$Age[males], patients$Weight[males],pch=16,col="steelblue")
points(patients$Age[females], patients$Weight[females],pch=17,col="orangered1")
legend("topleft", legend=c("M","F"), 
       col=c("steelblue","orangered1"), pch=c(16,17))
```

##Adding text

- text can also be added to a plot in a similar manner
    + the `labels` argument specifies the text we want to add
    
```{r fig.height=4,fig.width=8}
plot(patients$Age, patients$Weight,pch=16)
text(patients$Age, patients$Weight,labels=patients$Full_Name)
```

##Adding text

- can alter the positions so they don't interfere with the points of the graph
    
```{r fig.height=4,fig.width=8}
plot(patients$Age, patients$Weight,pch=16,xlim=c(10,70),ylim=c(60,75))
text(patients$Age-1, patients$Weight-0.5,labels=patients$Full_Name)
```

## Adding lines

- To aid our interpretation, it is often helpful to add guidelines
    + `grid()` is one easy way of doing this.
```{r}
plot(patients$Age, patients$Weight,pch=16)
grid(col="steelblue")
```

## Adding lines

- Can also add lines that intersect the axes
    + `v =` for vertical lines
    + `h=` for horizontal
    + can specify multiple lines in a vector
```{r}
plot(patients$Age, patients$Weight,pch=16)
abline(v=40,col="red")
abline(h=c(65,70,75),col="blue")
```


## Plot layouts

- The `par` function can be used specify the appearance of a plot
- The settings persist until the plot is closed with `dev.off`
- `?par` and scroll to ***graphical parameters***
- One example is `mfrow`
    + multiple figures per row
    + needs to be a vector of rows and columns
        + e.g. a plot with one row and two columns `par(mfrow=c(1,2))`
        + don't need the same kind of plot in each cell
        
## Plot layouts    
    
```{r}
par(mfrow=c(1,2))
plot(patients$Age, patients$Weight,pch=16,xlim=c(10,70),ylim=c(60,75))
boxplot(patients$Weight~patients$Sex)

```

- see also `mar` for setting the margins
    + `par(mar=c(...))`
    
## Exporting graphs from RStudio

- Easiest option to tuse the Export button from the Plots panel
- Otherwise, use the `pdf` function
    + you will see that the plot does not appear in RStudio
```{r eval=FALSE}
pdf("ExampleGraph.pdf")
plot(rnorm(1:10))
```

- you need to use the `dev.off` to stop printing graphs to the pdf and 'close' the file

```{r eval=FALSE}
dev.off()
```

## Exporting graphs from RStudio

- We can specify the dimensions of the plot, other properties of the file `?pdf`

```{r}
pdf("ExampleGraph.pdf",width=10,height=10)
plot(rnorm(1:10))
dev.off()
```

- Other formats can be created
    + e.g. ***png***
    
    
```{r}
png("ExampleGraph.png")
plot(rnorm(1:10))
dev.off()
```

##Exercise
- Return to the weather data from yesterday

```{r echo=FALSE}
weather <- read.csv("Day_1_scripts/ozone.csv")
```


```{r eval=FALSE}
weather <- read.csv("../Day_1_scripts/ozone.csv")
```

- Make a scatter plot of all daily observations of Ozone level
- Highlight any days which had Ozone level > 100
- Indicate which month the days with high ozone-level belong to

## Target Graph

```{r echo=FALSE}
plot(weather$Ozone,xlab="Day",ylab="Ozone level")
abline(h=100)
highO <- which(weather$Ozone > 100)
points(highO, weather$Ozone[highO],col="red",pch=16)
text(highO,weather$Ozone[highO]-5, labels=weather$Month[highO])
```

## Solution

```{r}
plot(weather$Ozone)
abline(h=100)
highO <- which(weather$Ozone > 100)
points(highO, weather$Ozone[highO],col="red",pch=16)
text(highO,weather$Ozone[highO]-5, labels=weather$Month[highO])
```


## Exercise

- Using the `par` function, create a layout with three columns
- Plot Ozone versus Solar Radiation, Wind Speed and Temperature on separate graphs
- Save the plot to a pdf

```{r echo=FALSE,fig.height=4,fig.width=10}
par(mfrow=c(1,3))
plot(weather$Solar.R,weather$Ozone,pch=16,col="lightgreen",ylab="Ozone level",xlab="Solar Radiation")
plot(weather$Wind,weather$Ozone, pch=15,col="steelblue",ylab="Ozone level", xlab="Wind Speed")
plot(weather$Temp,weather$Ozone,pch=17,col="orange", ylab="Ozone level",xlab="Temperature")

```

## Solution

```{r eval=FALSE}
pdf("ozoneCorrelations.pdf")
par(mfrow=c(1,3))
plot(weather$Solar.R,weather$Ozone,pch=16,col="lightgreen",ylab="Ozone level",xlab="Solar Radiation")
plot(weather$Wind,weather$Ozone, pch=15,col="steelblue",ylab="Ozone level", xlab="Wind Speed")
plot(weather$Temp,weather$Ozone,pch=17,col="orange", ylab="Ozone level",xlab="Temperature")
dev.off()
```


# 2. Statistics
##Built-in support for statistics
- R is a statistical programming language
    + Classical statistical tests are built-in
    + Statistical modeling functions are built-in
    + Regression analysis is fully supported
    + Additional mathematical packages are available (`MASS`, Waves, sparse matrices, etc)
  
##Distribution functions  
- Most commonly used distributions are built-in, functions have stereotypical names, e.g. for normal distribution
    + `pnorm` - cumulative distribution for x
    + `qnorm` - inverse of pnorm (from probability gives x)
    + `dnorm` - distribution density
    + `rnorm` - random number from normal distribution
  
![distributions](images/distributions.png)  
  
- available for variety of distributions: `punif` (uniform), `pbinom` (binomial), `pnbinom` (negative binomial), `ppois` (poisson), `pgeom` (geometric), `phyper` (hyper-geometric), `pt` (T distribution), pf (F distribution) 

##Distribution functions 
- 10 random values from the Normal distribution with mean 10 and standard deviation 5
```{r eval=FALSE}
rnorm(10, mean=10, sd=5)
```
- The probability of drawing 10 from this distribution
```{r}
dnorm(10, mean=10, sd=5)
```

```{r}
dnorm(100, mean=10, sd=5)
```
- The probability of drawing a value smaller than 10
```{r}
pnorm(10, mean=10, sd=5)
```
- The inverse of `pnorm`
```{r}
qnorm(0.5, mean=10, sd=5)
```
- How many standard deviations for statistical significance?
```{r}
qnorm(0.95, mean=0, sd=1)
```

## Example

Recall our histogram of temperature from yesterday

- the data look to be roughly normally-distributed
- an assumption we rely on for various statistical tests

```{r fig.height=4}
hist(weather$Temp,col="purple",xlab="Temperature",
     main="Distribution of Temperature",breaks = 50:100,freq=FALSE)
```

## Create a normal distribution curve

If our data are normally-distributed, we can calculate the probability of drawing particular values.

- e.g. a temperature of 80
- we can overlay this on the histogram using `points` as we just saw

```{r eval=FALSE}
dnorm(80, mean=tempMean,sd=tempSD)
hist(weather$Temp,col="purple",xlab="Temperature",
     main="Distribution of Temperature",breaks = 50:100,freq=FALSE)
points(80, dnorm(80, mean=tempMean,sd=tempSD),col="red",pch=16)
```


```{r fig.height=4,echo=FALSE}
tempMean <- mean(weather$Temp)
tempSD <- sd(weather$Temp)

dnorm(80, mean=tempMean,sd=tempSD)
hist(weather$Temp,col="purple",xlab="Temperature",
     main="Distribution of Temperature",breaks = 50:100,freq=FALSE)
points(80, dnorm(80, mean=tempMean,sd=tempSD),col="red",pch=16)
```



## Create a normal distribution curve

- we can repeat the calculation for a vector of values
    + remember that functions in R are often ***vectorized***
    + use `lines` in this case rather than `points`
    
    ```{r eval=FALSE}
xs <- c(50,60,70,80,90,100)
ys <- dnorm(xs, mean=tempMean,sd=tempSD)
lines(xs,ys,col="red",pch=16)
```

```{r fig.height=4,echo=FALSE}
hist(weather$Temp,col="purple",xlab="Temperature",
     main="Distribution of Temperature",breaks = 50:100,freq=FALSE)
xs <- c(50,60,70,80,90,100)
ys <- dnorm(xs, mean=tempMean,sd=tempSD)
lines(xs,ys,col="red",pch=16)
```



## Create a normal distribution curve

- For a smoother curve, use a longer vector
    + we can generate x values using the `seq` function

```{r eval=FALSE}
xs <- seq(50,100,length.out = 10000)
ys <- dnorm(xs, mean=tempMean,sd=tempSD)
lines(xs,ys,col="red",pch=16)
```


    
```{r fig.height=4,echo=FALSE}
hist(weather$Temp,col="purple",xlab="Temperature",
     main="Distribution of Temperature",breaks = 50:100,freq=FALSE)
xs <- seq(50,100,length.out = 10000)
ys <- dnorm(xs, mean=tempMean,sd=tempSD)
lines(xs,ys,col="red",pch=16)
```

## Simple testing

- If we want to compute the probability of observing a particular temperature, from the same distribution we can use the standard formula to calculate a t statistic:

$$t = \frac{\bar{x} -\mu_0}{s / \sqrt(n)}$$

```{r}
t <- (tempMean - 50) / (tempSD / sqrt(length(weather$Temp)))
t
```

- or use the `t.test` function to compute the statistic and corresponding p-value

```{r}
t.test(weather$Temp,mu=50)
```


##Two sample tests: Basic data analysis

- Comparing 2 variances
    + Fisher's F test
```{r eval=FALSE}
var.test()
```
- Comparing 2 sample means with normal errors
    + Student's t test
```{r eval=FALSE}
t.test()
```
- Comparing 2 means with non-normal errors
    + Wilcoxon's rank test
```{r eval=FALSE}
wilcox.test()
```

##Two sample tests: Basic data analysis
- Comparing 2 proportions
    + Binomial test
```{r eval=FALSE}
prop.test()
```
- Correlating 2 variables
    + Pearson's / Spearman's rank correlation
```{r eval=FALSE}
cor.test()
```
- Testing for independence of 2 variables in a contingency table
    + Chi-squared / Fisher's exact test
```{r eval=FALSE}
chisq.test();fisher.test()
```


## Example analysis

- We have already seen that men in our Patients dataset tend to be heavier than women
    + we can test this formally in R

```{r echo=FALSE}
par(mfrow=c(1,2))
plot(patients$Age, patients$Weight,pch=16,type="n")
points(patients$Age[males], patients$Weight[males],pch=16,col="steelblue")
points(patients$Age[females], patients$Weight[females],pch=17,col="orangered1")
legend("topleft", legend=c("M","F"), 
       col=c("steelblue","orangered1"), pch=c(16,17))
boxplot(patients$Weight~patients$Sex)
```

  
## Test variance assumption

```{r}
var.test(patients$Weight~patients$Sex)
```

## Perform the t-test


```{r}
t.test(patients$Weight~patients$Sex,var.equal=TRUE)
```

##Linear regression: Basic data analysis

- Linear modeling is supported by the function `lm()`
    + `example(lm)` the output assumes you know a fair bit about the subject

- `lm` is really useful for plotting lines of best fit to XY data in order to determine intercept, gradient & Pearson's correlation coefficient
    + This is very easy in R

- Three steps to plotting with a best fit line
  1. Plot XY scatter-plot data
  2. Fit a linear model
  3. Add bestfit line data to plot with `abline()` function
  
##Typical linear regression analysis: Basic data analysis

-  The ~ (***tilde***) is used to define a ***formula***; i.e. "y is given by x"

 
```{r fig.height=4}
x <- c(1, 2.3, 3.1, 4.8, 5.6, 6.3)
y <- c(2.6, 2.8, 3.1, 4.7, 5.1, 5.3)
plot(x,y, xlim=c(0,10), ylim=c(0,10))
```


##Typical linear regression analysis: Basic data analysis

 The ~ is used to define a formula; i.e. "y is given by x"
- Take care about the order of x and y in the plot and lm expressions

```{r}
plot(x,y, xlim=c(0,10), ylim=c(0,10))
myModel <- lm(y~x)
abline(myModel)
```

## In-depth summary

```{r}
summary(myModel)
```


##Typical linear regression analysis: Basic data analysis
- Get the coefficients of the fit from:
```{r}
coef(myModel)
resid(myModel)
fitted(myModel)
names(myModel)
```

## Diagnostic plots of the fit

- Get QC of fit from
```{r}
par(mfrow=c(2,2))
plot(myModel)
```

##Modelling formulae
- R has a very powerful formula syntax for describing statistical models
- Suppose we had two explanatory variables `x` and `z` and one response
variable `y`
- We can describe a relationship between, say, `y` and `x` using a tilde `~`,
placing the response variable on the left of the tilde and the explanatory variables on the right:
    + `y~x`
- It is very easy to extend this syntax to do multiple regressions, ANOVAs, to include interactions, and to do many other common modelling tasks. For example
```{r eval=FALSE}
y~x       #If x is continuous this is linear regression
y~x       #If x is categorical, this is ANOVA
y~x+z     #If x and z are continuous, this is multiple regression
y~x+z     #If x and z are categorical, this is two-way ANOVA
y~x+z+x:z # : is the symbol for the interaction term
y~x*z     # * is a shorthand for x+z+x:z
```


## Exercise

- There are suggestions that Ozone level could be influenced by Temperature

```{r echo=FALSE,fig.height=4}
plot(weather$Temp, weather$Ozone,xlab="Temperature",ylab="Ozone level",pch=16)
```

- Perform a linear regression analysis to assess this
    + fit the linear model and print a summary of the output
    + plot the two variables and overlay a best-fit line

## Solution
```{r fig.show=FALSE}
mod1 <- lm(weather$Ozone~weather$Temp)
summary(mod1)
```

## Solution
```{r}
plot(weather$Temp, weather$Ozone,pch=16)
abline(mod1,col="red",lty=2)
```




# 3. Report Writing

##The R scripting language


* A script is a series of instructions that when executed sequentially automates a task
    + A script is a good solution to a repetitive problem
* The art of good script writing is
    + understanding exactly what you want to do
    + expressing the steps as concisely as possible
    + making use of error checking
    + including descriptive comments
* R is a powerful scripting language, and embodies aspects found in most standard programming environments
    + procedrual statements
    + loops
    + functions
    + conditional branching
* Scripts may be written in any standard text editor, e.g. notepad, gedit, kate
    + we will use RStudio

## Principles of Reproducible Research

![step-two](images/SidneyHarris_MiracleWeb.jpg)

Sidney Harris - New York Times

## Why should we do reproducible research?

Five selfish reasons - [Florian Markowetz Blog](https://scientificbsides.wordpress.com/2015/07/15/five-selfish-reasons-for-working-reproducibly/) and [slides](http://f1000research.com/slides/4-207)

1. Avoid disaster
2. Easier to write papers
3. Easier to talk to reviewers
4. Continuity of your work in the lab
5. Reputation


##It is a hot topic at the moment

- Statisticians at MD Anderson tried to reproduce results from a Duke paper and unintentionally unravelled a web of incompetence and skullduggery
    + as reported in the ***New York Times***
    
![nyt-article](images/rep-research-nyt.png)

##Hear the full account

- Very entertaining talk from Keith Baggerly in Cambridge 2010

<iframe width="560" height="315" src="https://www.youtube.com/embed/7gYIs7uYbMo" frameborder="0" allowfullscreen></iframe>


##What can we do about it?

- Use scripts / R
- Use version control
- Document early
- Document everything
- Write comments and explanations
- Automatically-generate your plots, tables, etc from the data
    + always ensure that you have the latest version

##Simple example in RStudio
- Lets take Day_1_scripts/1.3_NBcountData.R
- Use the Compile Notebook button in RStudio
- Take an R script and turn into HTML, PDF or even Word
- All code will be displayed and the outputs printed
- A compiled report will be generated in your working directory

![compile](images/RStudio-menu.png)



## What is going on?

- The `knitr` package is being used convert the R script into 'markdown' format, which it then compiles into the output of your choosing
- `knitr` is distributed with RStudio
    + `knitr` is the modern-day equivalent of `Sweave`
- markdown is a easy-to-read, easy-to-write text format often used to write HTML, readme files etc
- the following should create the file `rna-seq.Rmd` in the Day_1_scripts folder

```{r eval=FALSE}
library(knitr)
spin(hair="../Day_1_scripts/1.3_NBcountData.R",knit=FALSE)
```

## Not quite enough for a reproducible document

- Minimally, you should record what version of R, and the packages you used.
- use the `sessionInfo()` function
    + e.g. for the version of R I used to make the slides
```{r}
sessionInfo()
```

- Lets add this to the R scripts and see what happens


## Defining chunks

- It is not great practice to have one long, continuous R script
- Better to break-up into smaller pieces; '*chunks*'
- You can document each chunk separately
- Easier to catch errors
- The characteristics of each chunk can be modified
    + You might not want to print the R code for each chunk
    + or the output
    + etc

## Create a markdown file from scratch

File - > New File - > R Markdown

- Choose 'Document' and the default output type (HTML)
- A new tab is created in RStudio
- The header also you to specify a Page title, author and output type
```{r eval=FALSE}
---
title: "Untitled"
author: "Mark Dunning"
date: "16/06/2015"
output: html_document
---
```

## Format of the file

- **Lines 8 - 10** Plain text description
- **Lines 12 - 14** An R code 'chunk'
- **Lines 18 to 20** Another code chunk, this time producing a plot

![md-format](images/markdown-format.png)

- Pressing the ***Knit HTML*** button will create the report
    + Note that you need to 'save' the markdown file before you will see the compiled report in your working directory
    
##Text formatting
See ***Markdown Quick Reference*** in RStudio

- enclose text in \* to format in *italics*
- enclose text in \*\* to format in **bold**
- \*\*\* for ***bold italics***
- \` to format like `code`
- \$ to include equations: $e =mc^2$
- \> quoted text: 

>To be or not to be

- see Markdown Quick Reference for more 
    + adding images
    + adding web links
    + tables

## Chunk options

- It's a good idea to name each chunk
    + Easier to track-down errors
- We can display R code, but not run it
    + `eval=FALSE`
- We can run R code, but not display it
    + `echo=FALSE`
    + e.g. setting display options
- Suppress warning messages
    + `warning=FALSE`

    
## Chunk options: eval

- Sometimes we want to format code for display, but not execute
    + we want to show the code for how we read our data, but want our report to compile quickly

```
'''{r,eval=FALSE}
data <- read.delim("path.to.my.file")
'''
```


## Chunk options: echo

- might want to load some data from disk
    + e.g. the R object from reading the data in the previous slide
- your P.I. wants to see your results, but doesn't really want to know about the R code that you used
```
'''{r echo=FALSE}
load("mydata.rda")
'''
```

## Chunk options: results

- Some code or functions might produce lots of output to the screen that we don't need
```{r results='hide'}
for(i in 1:100){
  print(i)
}
```

##Chunk options: message and warning

- Loading an R package will sometimes print messages and / or warnings to the screen
    + not always helpful in a report
```
'''{r}
library(DESeq)
'''
```

```{r echo=FALSE}
library(DESeq)
```

##Chunk options: message and warning

- Using `message=FALSE` and `warning=FALSE`
```
'''{r message=FALSE,warning=FALSE}
library(DESeq)
'''
```
- Could also need `suppressPackageStartupMessages`

##Chunk options: cache

- `cache=TRUE` will stop certain chunks from being evaluate if their code does not change
- speeds-up the compilation of the document
    + we don't want to reload our dataset if we've only made a tiny change downstream
```
'''{r echo=FALSE,cache=TRUE}
load("mydata.rda")
'''
```

## Including plots

- Use a plotting function (`plot`, `boxplot`, `hist` etc) will include the plot at the relevant point in the document
```
'''{r}
plot(1:10, jitter(1:10))
'''
```

```{r echo=FALSE}
plot(1:10, runif(10))
```

## Control over plots

```
'''{r fig.height=2,fig.align='right', fig.height=4,fig.width=9}
plot(1:10, jitter(1:10))
'''
```

```{r echo=FALSE,fig.height=3,fig.align='right', fig.height=4,fig.width=9}
plot(1:10, runif(10))
```


## Running R code from the main text

- We can add R code to our main text, which gets evaluated
    + make sure we always have the latest figures, p-values etc

```
.....the sample population consisted of  'r table(gender)[1]' females and 'r table(gender)[2]' males.....
```

```{r echo=FALSE}
gender <- c(rep("F", 47), rep("M", 50))
```
.....the sample population consisted of  `r table(gender)[1]` females and `r table(gender)[2]` males.....



```
.....the p-value of the t-test is 'r pval', which indicates that.....
```
```{r echo=FALSE}
pval <- 0.05
```
.....the p-value of the t-test is `r pval`, which indicates that.....

## Running R code from the main text

- Like the rest of our report these R statements will get updated each time we compile the report

```
.....the sample population consisted of  'r table(gender)[1]' females and 'r table(gender)[2]' males.....
```

```{r echo=FALSE}
gender <- c(rep("F", 41), rep("M", 54))
```
.....the sample population consisted of  `r table(gender)[1]` females and `r table(gender)[2]` males.....



```
.....the p-value of the t-test is 'r pval', which indicates that.....
```
```{r echo=FALSE}
pval <- 0.1
```
.....the p-value of the t-test is `r pval`, which indicates that.....



## Conditional output

```{r}
pval <- 0.1
```


```
.....The statistical test was 'r ifelse(pval < 0.05, "", "not")' significant....
```



The statistical test was `r ifelse(pval < 0.05, "", "not")` significant

```{r}
pval <- 0.01
```


```
.....The statistical test was 'r ifelse(pval < 0.05, "", "not")' significant....
```


The statistical test was `r ifelse(pval < 0.05, "", "not")` significant



## References

- Useful reference:
    +  Reproducible Research in R and RStudio
        + http://christophergandrud.github.io/RepResR-RStudio/
        + Useful exercise is to compile the book from the [source code](https://github.com/christophergandrud/Rep-Res-Book)
    + [Implementing Reproducible Research](https://osf.io/s9tya/wiki/home/)


## Exercise

- Create a new markdown file that will report your analysis of the NB count data
    + File -> New File -> R Markdown
- Create separate code chunks for each stage of the analysis (copy code from Day_1_scripts/1.3_NBcountData.R if you wish)
    + Reading the data and print the first few rows
    + Identify patients with >33% NB amplification
    + Plot and identify the outliers
    + Write out results table as comma separated values file
    
## Exercise

- Once you have a report that you are happy with
- Use in-line R code to report how many patients have > 33% amplifications
- Hide the code chunk used to produce the plot (`echo=FALSE`)
- Cache the code chunk used to read the raw data (`cache=TRUE`)
- Modify the selection criteria for amplification to be > 30%
    + see how the various parts of the report change
- Solution: *NBcounts-analysis.Rmd*


# 4. Data Manipulation Techniques

## Motivation

- So far we have been lucky that all our data have been in the same file
    + This is not usually the case
    + A dataset may be spread over severall files
        + This takes longer, and is harder, than many people realise
    + We need to combine before doing an analysis



## Combining data from multiple sources: Gene Clustering Example

- R has powerful functions to combine heterogeneous data sources into a single data set
- Gene clustering example data
    + gene expression values in ***Day_2_scripts/gene.expression.txt***
    + patient information in ***Day_2_scripts/gene.description.txt***
    + gene information in ***Day_2_scripts/cancer.patients.txt***
- A breast cancer dataset with numerous patient characteristics 
    + we will concentrate on ***ER status*** (positive / negative)
    + what genes show a statistically-significant different change between ER groups?


```{r echo=FALSE}

if(!file.exists("Day_2_scripts/gene.expression.txt")){

  if(!require(breastCancerNKI) | require(genefilter)) {
    source("http://www.bioconductor.org/biocLite.R")
    biocLite(c("breastCancerNKI","genefilter"))
  }
  data("nki")
  cancer.patients <- pData(nki)[,c("samplename","age","er","grade")]
  genes <- fData(nki)[,c("probe","HUGO.gene.symbol")]
  ##get the top50 DE genes, plus 500 random
  ps <- NULL
  for(i in 1:nrow(genes)){
    ps[i] <- t.test(exprs(nki)[i,] ~ factor(cancer.patients$er))$p.value
  }
  set.seed(070815)
  ind <- order(ps, decreasing = FALSE)[1:50]
  ind <- sort(c(ind, sample(setdiff(1:nrow(genes),ind),500)))
  
  evalues <- exprs(nki)[ind,]
  cancer.patients <- cancer.patients[order(cancer.patients$age),]
  genes <- genes[order(genes[,1]),]
  
  write.table(evalues, file="Day_2_scripts/gene.expression.txt",quote=FALSE,sep="\t")
  write.table(genes, file="Day_2_scripts/gene.description.txt",quote=FALSE,sep="\t")
  write.table(cancer.patients, file="Day_2_scripts/cancer.patients.txt",quote=FALSE,sep="\t")
}
```


## Analysis sketch

- Read the relevant files
- Do a sanity check to see if a known gene exhibits a change between groups
- Use a t-test to rank all genes
- Make heatmaps of the top hits
    
## Peek at the data

```{r eval=FALSE}
evals <- read.delim("gene.expression.txt",stringsAsFactors = FALSE)
evals[1:5,1:5]
dim(evals)
```

```{r echo=FALSE}
evals <- read.delim("Day_2_scripts/gene.expression.txt",stringsAsFactors = FALSE)
evals[1:5,1:5]
dim(evals)
```
- `r nrow(evals)` rows and `r ncol(evals)` columns
+ One row for each gene
    + rows are named according to particular technology used to make measurement
+ One column for each patient

## Peek at the data
```{r eval=FALSE}
genes <- read.delim("gene.description.txt")
head(genes)
dim(genes)
```

```{r echo=FALSE}
genes <- read.delim("Day_2_scripts/gene.description.txt")
head(genes)
dim(genes)
```


- `r nrow(genes)` rows and `r ncol(genes)` columns
- One for for each gene
    + more rows than genes we have measurements for
- Includes mapping between manufacturer ID and Gene name

## Peek at the data
```{r eval=FALSE}
subjects <- read.delim("cancer.patients.txt")
head(subjects)
dim(subjects)
```


```{r echo=FALSE}
subjects <- read.delim("Day_2_scripts/cancer.patients.txt")
head(subjects)
dim(subjects)
```

- One for for each patient in the study
- Each column is a different characteristic of that patient
    + e.g. whether a patient is ER positive or negative

```{r}
table(subjects$er)
```


## Retrieving data for a particular gene

 - Gene `ESR1` is known to be hugely-different between ER positive and negative patient
    + let's check that this is evident in our dataset
    + if not, something has gone wrong!
- First step is to locate this gene in our dataset

## Character matching in R

- we have already seen various ways of comparing numeric values
    + ==, >, <
    + each of which returns a vector of logical values
    + == will also work with text
    
```{r}
LETTERS
"A" == LETTERS
```

## Character matching in R
    
- `match` and `grep` are often used to find particular matches
    + CAUTION: by default, match will only return the ***first*** match!

```{r}
match("D", LETTERS)
grep("F", rep(LETTERS,2))
match("F", rep(LETTERS,2))
```

## Retrieving data for a particular gene

- find the name of the ID that corresponds to gene ***ESR1***
    + mapping between IDs and genes is in the ***genes*** data frame
        + ID in first column, gene name in the second
- save this probe as a variable

```{r}
ind <- match("ESR1", genes[,2])
genes[ind,]
probe <- genes[ind,1]
probe
```


## Retrieving data for a particular gene

Now, find which row in our expression matrix is indexed by this ID

```{r}
match(probe,rownames(evals))
evals[match(probe,rownames(evals)),1:10]
genevals <- evals[match(probe,rownames(evals)),]
```

## Relating to patient characteristics

- oh dear!

```{r fig.height=3}
boxplot(as.numeric(genevals)~factor(subjects$er))
t.test(as.numeric(genevals)~factor(subjects$er))
```

## The right patients, but not neccessarily in the right order!

- the problem is that our expression values are not in the same order as the clinical data
    + a common occurence :/

```{r}
colnames(evals)[1:10]
subjects$samplename[1:10]
colnames(evals)[1:10] == subjects$samplename[1:10]
```


## Re-ordering both matrices

- we can use `match` to re-order
- the result is a vector
    + first value is the column in expression matrix that the first row in the clinical data corresponds to
    + etc
    
```{r}
match(subjects$samplename,colnames(evals))

```

## Re-ordering both matrices

- we can use this vector to index our expression matrix
    + remembering to omit the row index
- sanity check to make sure we've done the job

```{r}
evals <- evals[,match(subjects$samplename,colnames(evals))]
genevals <- evals[match(probe,rownames(evals)),]
colnames(evals)[1:10] == subjects$samplename[1:10]
all(colnames(evals) == subjects$samplename)

```


## Try again

- Much better!

```{r fig.height=3}
boxplot(as.numeric(genevals)~factor(subjects$er))
t.test(as.numeric(genevals)~factor(subjects$er))
```


##Introducing loops

- Many programming languages have ways of doing the same thing many times, perhaps changing some variable each time. This is called *looping*
- Loops are not used in R so often, because we can usually achieve the same thing using vector calculations
- For example, to add two vectors together, we do not need to add each pair of elements one by one, we can just add the vectors
```{r eval=FALSE}
x<- 1:10
y <- 11:20
x+y
```
- But there are some situations where R functions can not take vectors as input. For example, `t.test` will only test one gene at a time
- What if we wanted to test multiple genes?

##Introducing loops
- We could do this:

```{r eval=FALSE}
t.test(evals[1,]~factor(subjects$er))
t.test(evals[2,]~factor(subjects$er))

```

- But this will be boring to type, difficult to change, and prone to error
- As we are doing the same thing multiple times, but with a different index each time, we can use a **loop** instead

##Loops: Commands and flow control
- R has two basic types of loop
    + a `for` loop: run some code on every value in a vector
    + a `while` loop: run some code while some condition is true
    
`for` 
```{r loops1, eval=FALSE}
for(i in 1:10){
  print(i)
}
```
`while`
```{r  eval=FALSE}
i <- 1
while ( i <= 10 ) {
   print(i)
   i <- i + 1
}
```

##Loops: Commands and flow control

- Here's how we might use a `for` loop to test the first 10 genes
- However, we are not storing the results of each calculation

```{r loops2, eval=FALSE}

for (i in 1:10) {
   t.test(as.numeric(evals[i,])~factor(subjects$er))
}
```

## Looping

```{r}
for (i in 1:10) {
   print(t.test(as.numeric(evals[i,])~factor(subjects$er)))
}
```


## Storing results

```{r}
t <- t.test(as.numeric(evals[i,])~factor(subjects$er))
names(t)
t$statistic
```

## Storing results

```{r}
stats <- NULL
for (i in 1:10) {
   tmp <- t.test(as.numeric(evals[i,])~factor(subjects$er))
   stats[i] <- tmp$statistic
}
stats
```

## Modifying code to work on a gene-list

- What if we want to test and arbitrary gene list
- Supply gene list as a vector
- Add extra steps to locate correct row in matrix

```{r eval=FALSE}
stats <- NULL

for(i in 1:length(genelist)){
  
  probe <- genes[match(genelist[i],genes[,2]),1]
  j <- match(probe,rownames(evals))
  
  tmp <- t.test(as.numeric(evals[j,])~factor(subjects$er))
  stats[i] <- tmp$statistic

}

```

## Example

```{r}
stats <- NULL
genelist <- c("ESR1", "NAT1", "SUSD3","SLC7A2" ,"SCUBE2")

for(i in 1:length(genelist)){
  
  probe <- genes[match(genelist[i],genes[,2]),1]
  j <- match(probe,rownames(evals))
  
  tmp <- t.test(as.numeric(evals[j,])~factor(subjects$er))
  stats[i] <- tmp$statistic

}
stats
```

## Introducing error-checking

- what happens when we try and run this?
- should see an error as ***foo*** and ***bar*** are not defined in our gene table
    + the error message is often obtuse
    + we can anticipate this kind of error in advance

```{r eval=FALSE}
stats <- NULL
genelist <- c("foo", "bar")

for(i in 1:length(genelist)){
  
  probe <- genes[match(genelist[i],genes[,2]),1]
  j <- match(probe,rownames(evals))
  
  tmp <- t.test(as.numeric(evals[j,])~factor(subjects$er))
  stats[i] <- tmp$statistic

}
stats
```


##Conditional branching: Commands and flow control

- Use an `if` statement for any kind of condition testing
- Different outcomes can be selected based on a condition within brackets

```{r if, eval=FALSE}
if (condition) {
... do this ...
} else {
... do something else ...
}

```

- `condition` is any logical value, and can contain multiple conditions. 
    + e.g. `(a == 2 & b < 5)`, this is a compound conditional argument

##Conditional branching: Commands and flow control
- Using the `for` loop we wrote before, we might want to warn the user if we can't find a particular gene with the pattern we are searching for. 
- Here's how we can use an `if` statement to test for this
    + only run the t-test if we can successfully map the gene
    
```{r flow-control,eval=FALSE}
stats <- NULL

for(i in 1:length(genelist)){
  
  probes <- genes[match(genelist[i],genes[,2]),1]
  j <- match(probes,rownames(evals))
  
  if(length(probes)>0){
   tmp <- t.test(as.numeric(evals[j,])~factor(subjects$er))
   stats[i] <- tmp$statistic
  }
  
  }
```


##Code formatting avoids bugs!
Compare:
```{r eval=FALSE}
f -26
while(f!=0){
print(letters[f])
f <- f-1}
```
to:
```{r eval=FALSE}
f <- 26
while( f != 0 ){
   print(letters[f])
   f <- f-1
}
```
- The code between brackets `{}` *always* is *indented*, this clearly separates what is executed once, and what is run multiple times
- Trailing bracket `}` always alone on the line at the same indentation level as the initial bracket `{`
- Use white spaces to divide the horizontal space between units of your code, e.g. around assignments, comparisons


## Extracing multiple genes

```{r}
genelist <- c("ESR1", "NAT1", "SUSD3","SLC7A2" ,"SCUBE2","foo")
stats <- NULL
for(i in 1:length(genelist)){
  
  probes <- genes[match(genelist[i],genes[,2]),1]
  j <- match(probes,rownames(evals))
  
  if(!is.na(probes)){
   tmp <- t.test(as.numeric(evals[j,])~factor(subjects$er))
   stats[i] <- tmp$statistic
   
  }
  else message("Could not find gene ", genelist[i])
  
}
stats
```

## Plotting genes

```{r}
genelist <- c("ESR1", "NAT1", "SUSD3","SLC7A2" ,"SCUBE2")
stats <- NULL
for(i in 1:length(genelist)){
  
  probes <- genes[match(genelist[i],genes[,2]),1]
  j <- match(probes,rownames(evals))
  
  if(length(probes)>0){
   tmp <- t.test(as.numeric(evals[j,])~factor(subjects$er))
   stats[i] <- tmp$statistic
   boxplot(as.numeric(evals[j,])~factor(subjects$er),main=genelist[i],xlab="ER Status")
  }
  
}
stats


```



## Compiling the report

- See the markdown document gene-report.Rmd

# End of Course

## Wrap-up

- Thanks for your attention
- Practice, practice, practice
    + ....& persevere
- Need inspiration?
    + Read [blogs](http://www.r-bloggers.com/)
    + Follow the [forums](http://stackoverflow.com/questions/tagged/r)
    + Download [datasets](http://vincentarelbundock.github.io/Rdatasets/datasets.html) to practice with
    + on twitter @rstudio, @Rbloggers, @RLangTip
    