---
title: "Introduction to Solving Biological Problems Using R - Day 2"
author: Mark Dunning and Aiora Zabala. Original material by Robert Stojnić, Laurent Gatto, Rob Foy
  John Davey, Dávid Molnár and Ian Roberts
date: '`r format(Sys.time(), "Last modified: %d %b %Y")`'
output: slidy_presentation
toc: yes
---

## Day 2 Schedule

1. Further customisation of plots
2. Statistics
3. Report-writing
4. Data Manipulation Techniques
5. Data analysis report

#1. Further customisation of plots

## Recap

- we have seen how to use `plot`, `boxplot` `hist` to make simple plots
- these come with arguments that can be used to change the appearance of the plot
    + `col`, `pch`
    + `main`, `xlab`, `ylab`
    + etc....
- we will now look at ways to modify the plot appearance after it has been created

## The painter's model

- R employs a painter's model to construct it's plots
- Elements of the graph are added to the canvas one layer at a time, and the picture built up in levels. Lower levels are obscured by higher levels, allowing for blending, masking and overlaying of objects.

##Initial plot

- Recall our weather dataset from yesterday
```{r results='hide'}
source("Day_1_scripts/1.2_patients.R")
```

```{r}
plot(patients$Age, patients$Weight,pch=16)
```

##The points function

- `points` can be used to set of points to an *existing* plot
- it requires a vector of x and y coordinates
    + these do not have to be the same length as the number of points in the initial plot
        + hence we can use `points` to highlight observations
        + or add a set of new observations
- Note that axis limits of the existing plot are not altered

```{r}
plot(patients$Age, patients$Weight,pch=16)
points(40,68,pch="X")
```


## Creating a blank plot

- Often it is useful to create a blank 'canvas' with the correct labels and limits

```{r}
plot(patients$Age, patients$Weight,pch=16,type="n")
```

## Adding points to differentiate gender

- Selecting males using the `==` comparison we saw yesterday
    + gives a `TRUE` or `FALSE` value
    + can be used to index the data frame
    + which means we can get the relevant Age and Weight values
```{r}
males <- patients$Sex == "Male"
males
patients[males,]
patients[males,"Age"]
patients[males,"Weight"]
```

## Adding points to differentiate gender

```{r}
plot(patients$Age, patients$Weight,pch=16,type="n")
points(patients$Age[males], patients$Weight[males],pch=16,col="steelblue")

```


## Adding points to differentiate gender


```{r}
females <- patients$Sex == "Female"
females
patients[females,]
```

## Adding points to differentiate gender

```{r}
plot(patients$Age, patients$Weight,pch=16,type="n")
points(patients$Age[males], patients$Weight[males],pch=16,col="steelblue")
points(patients$Age[females], patients$Weight[females],pch=16,col="orangered1")

```


##Adding points

- Each set of points can have a different colour and shape
- Axis labels and title and limits are defined by the plot
- You can add points ad-nauseum. Try not to make the plot cluttered!
- A call to `plot` will start a new graphics window


```{r fig.height=4,fig.width=8}
plot(patients$Age, patients$Weight,pch=16,type="n")
points(patients$Age[males], patients$Weight[males],pch=16,col="steelblue")
points(patients$Age[females], patients$Weight[females],pch=17,col="orangered1")
```



## Adding a legend

```{r fig.height=4,fig.width=8}
plot(patients$Age, patients$Weight,pch=16,type="n")
points(patients$Age[males], patients$Weight[males],pch=16,col="steelblue")
points(patients$Age[females], patients$Weight[females],pch=17,col="orangered1")
legend("topleft", legend=c("M","F"), 
       col=c("steelblue","orangered1"), pch=c(16,17))
```

##Adding text


```{r fig.height=4,fig.width=8}
plot(patients$Age, patients$Weight,pch=16)
text(patients$Age, patients$Weight,labels=patients$Full_Name)
```

##Adding text

- text can also be added to a plot in a similar manner
    + the `labels` argument specifies the text we want to add
    
```{r fig.height=4,fig.width=8}
plot(patients$Age, patients$Weight,pch=16,xlim=c(10,70),ylim=c(60,75))
text(patients$Age-1, patients$Weight-0.5,labels=patients$Full_Name)
```

## Adding lines

- To aid our interpretation, it is often helpful to add guidelines
    + `grid()` is one easy way of doing this.
```{r}
plot(patients$Age, patients$Weight,pch=16)
grid(col="steelblue")
```

## Adding lines

- Can also add lines that intersect the axes
    + `v =` for vertical lines
    + `h=` for horizontal
    + can specify multiple lines in a vector
```{r}
plot(patients$Age, patients$Weight,pch=16)
abline(v=40,col="red")
abline(h=c(65,70,75),col="blue")
```


## Plot layouts

- The `par` function can be used specify the appearance of a plot
- The settings persist until the plot is closed with `dev.off`
- `?par` and scroll to ***graphical parameters***
- One example is `mfrow`
    + multiple figures per row
    + needs to be a vector of rows and columns
        + e.g. a plot with one row and two columns `par(mfrow=c(1,2))`
    
```{r}
par(mfrow=c(1,2))
plot(patients$Age, patients$Weight,pch=16,xlim=c(10,70),ylim=c(60,75))
boxplot(patients$Weight~patients$Sex)

```

##Exercise
- Return to the weather data from yesterday

```{r}
data <- read.csv("Day_1_scripts/ozone.csv")
```

- Make a scatter plot of all daily observations of Ozone level
- Highlight any days which had Ozone level > 100
- Indicate which month the days with high ozone-level belong to

## Target Graph

```{r echo=FALSE}
plot(data$Ozone,xlab="Day",ylab="Ozone level")
abline(h=100)
highO <- which(data$Ozone > 100)
points(highO, data$Ozone[highO],col="red",pch=16)
text(highO,data$Ozone[highO]-5, labels=data$Month[highO])
```

## Solution

```{r}
plot(data$Ozone)
abline(h=100)
highO <- which(data$Ozone > 100)
points(highO, data$Ozone[highO],col="red",pch=16)
text(highO,data$Ozone[highO]-5, labels=data$Month[highO])
```


## Exercise

- Using the `par` function, create a layout with three columns
- Plot Ozone versus Solar Radiation, Wind Speed and Temperature on separate graphs

```{r echo=FALSE}
par(mfrow=c(1,3))
plot(data$Solar.R,data$Ozone,pch=16,col="lightgreen",ylab="Ozone level",xlab="Solar Radiation")
plot(data$Wind,data$Ozone, pch=15,col="steelblue",ylab="Ozone level", xlab="Wind Speed")
plot(data$Temp,data$Ozone,pch=17,col="mistyrose", ylab="Ozone level",xlab="Temperature")

```

## Solution

```{r}

par(mfrow=c(1,3))
plot(data$Solar.R,data$Ozone,pch=16,col="lightgreen",ylab="Ozone level",xlab="Solar Radiation")
plot(data$Wind,data$Ozone, pch=15,col="steelblue",ylab="Ozone level", xlab="Wind Speed")
plot(data$Temp,data$Ozone,pch=17,col="mistyrose", ylab="Ozone level",xlab="Temperature")

```


    
## More-Advanced 

- Modification to include month name and date

```{r}
plot(data$Ozone)
abline(h=100)
highO <- which(data$Ozone > 100)
points(highO, data$Ozone[highO],col="red",pch=16)
text(highO,data$Ozone[highO]-5, labels=paste(month.abb[data$Month[highO]],data$Day[highO]))

```

# 2. Statistics
##Built-in support for statistics
- R is a statistical programming language
    + Classical statistical tests are built-in
    + Statistical modeling functions are built-in
    + Regression analysis is fully supported
    + Additional mathematical packages are available (`MASS`, Waves, sparse matrices, etc)
  
##Distribution functions  
- Most commonly used distributions are built-in, functions have stereotypical names, e.g. for normal distribution
    + `pnorm` - cumulative distribution for x
    + `qnorm` - inverse of pnorm (from probability gives x)
    + `dnorm` - distribution density
    + `rnorm` - random number from normal distribution
  
![distributions](images/distributions.png)  
  
- available for variety of distributions: `punif` (uniform), `pbinom` (binomial), `pnbinom` (negative binomial), `ppois` (poisson), `pgeom` (geometric), `phyper` (hyper-geometric), `pt` (T distribution), pf (F distribution) 

##Distribution functions 
- 10 random values from the Normal distribution with mean 10 and standard deviation 5
```{r eval=FALSE}
rnorm(10, mean=10, sd=5)
```
- The probability of drawing 10 from this distribution
```{r}
dnorm(10, mean=10, sd=5)
```

```{r}
dnorm(100, mean=10, sd=5)
```
- The probability of drawing a value smaller than 10
```{r}
pnorm(10, mean=10, sd=5)
```
- The inverse of `pnorm`
```{r}
qnorm(0.5, mean=10, sd=5)
```
- How many standard deviations for statistical significance?
```{r}
qnorm(0.95, mean=0, sd=1)
```

##Two sample tests: Basic data analysis

- Comparing 2 variances
    + Fisher's F test
```{r eval=FALSE}
var.test()
```
- Comparing 2 sample means with normal errors
    + Student's t test
```{r eval=FALSE}
t.test()
```
- Comparing 2 means with non-normal errors
    + Wilcoxon's rank test
```{r eval=FALSE}
wilcox.test()
```

##Two sample tests: Basic data analysis
- Comparing 2 proportions
    + Binomial test
```{r eval=FALSE}
prop.test()
```
- Correlating 2 variables
    + Pearson's / Spearman's rank correlation
```{r eval=FALSE}
cor.test()
```
- Testing for independence of 2 variables in a contingency table
    + Chi-squared / Fisher's exact test
```{r eval=FALSE}
chisq.test();fisher.test()
```


## Example analysis

- We have already seen that men in our Patients dataset tend to be heavier than women
    + we can test this formally in R

```{r echo=FALSE}
par(mfrow=c(1,2))
plot(patients$Age, patients$Weight,pch=16,type="n")
points(patients$Age[males], patients$Weight[males],pch=16,col="steelblue")
points(patients$Age[females], patients$Weight[females],pch=17,col="orangered1")
legend("topleft", legend=c("M","F"), 
       col=c("steelblue","orangered1"), pch=c(16,17))
boxplot(patients$Weight~patients$Sex)
```

  
## Test variance assumption

```{r}
var.test(patients$Weight~patients$Sex)
```

## Perform the t-test


```{r}
t.test(patients$Weight~patients$Sex,var.equal=TRUE)
```

## Exercise

- From our weather dataset, it would appear that the ozone level is higher in the summer months (June or July)
```{r}
boxplot(data$Ozone~data$Month)
```

- Is there sufficient statistical evidence to support this claim?
    + ***Hint**: You need to create a categorical variable to indicate whether a particular measurement was made in the summer or not

## Solution

```{r}
Summer <- data$Month > 6 & data$Month < 9
boxplot(data$Ozone ~ Summer)
t.test(data$Ozone ~ Summer)
```

  
##Linear regression: Basic data analysis

- Linear modeling is supported by the function `lm()`
    + `example(lm)` the output assumes you know a fair bit about the subject

- `lm` is really useful for plotting lines of best fit to XY data in order to determine intercept, gradient & Pearson's correlation coefficient
    + This is very easy in R

- Three steps to plotting with a best fit line
  1. Plot XY scatter-plot data
  2. Fit a linear model
  3. Add bestfit line data to plot with `abline()` function
  
##Typical linear regression analysis: Basic data analysis

-  The ~ (***tilde***) is used to define a ***formula***; i.e. "y is given by x"*

 
```{r fig.height=4}
x <- c(1, 2.3, 3.1, 4.8, 5.6, 6.3)
y <- c(2.6, 2.8, 3.1, 4.7, 5.1, 5.3)
plot(x,y, xlim=c(0,10), ylim=c(0,10))
```


##Typical linear regression analysis: Basic data analysis

 The ~ is used to define a formula; i.e. "y is given by x"
- Take care about the order of x and y in the plot and lm expressions

```{r}
plot(x,y, xlim=c(0,10), ylim=c(0,10))
myModel <- lm(y~x)
abline(myModel)
```

## In-depth summary

```{r}
summary(myModel)
```


##Typical linear regression analysis: Basic data analysis
- Get the coefficients of the fit from:
```{r}

coef(myModel)
resid(myModel)
fitted(myModel)
names(myModel)
```

## Diagnostic plots of the fit

- Get QC of fit from
```{r}
par(mfrow=c(2,2))
plot(myModel)
```

##Modelling formulae
- R has a very powerful formula syntax for describing statistical models
- Suppose we had two explanatory variables `x` and `z` and one response
variable `y`
- We can describe a relationship between, say, `y` and `x` using a tilde `~`,
placing the response variable on the left of the tilde and the explanatory variables on the right:
    + `y~x`
- It is very easy to extend this syntax to do multiple regressions, ANOVAs, to include interactions, and to do many other common modelling tasks. For example
```{r eval=FALSE}
y~x       #If x is continuous this is linear regression
y~x       #If x is categorical, this is ANOVA
y~x+z     #If x and z are continuous, this is multiple regression
y~x+z     #If x and z are categorical, this is two-way ANOVA
y~x+z+x:z # : is the symbol for the interaction term
y~x*z     # * is a shorthand for x+z+x:z
```


## Exercise

- There are suggestions that Ozone level could be influenced by Temperature and Wind speed

```{r echo=FALSE,fig.height=4}
par(mfrow=c(1,2))
plot(data$Temp, data$Ozone,xlab="Temperature",ylab="Ozone level",pch=16)
plot(data$Wind, data$Ozone,xlab="Wind Speed",ylab="Ozone level",pch=16)
```

- Perform a linear regression analysis to assess this
    + fit the linear model and print a summary of the output
    + plot the two variables and overlay a best-fit line

## Solution
```{r}
plot(data$Temp, data$Ozone,pch=16)
mod <- lm(data$Ozone~data$Temp)
summary(mod)
abline(mod,col="red",lty=2)
```

## Solution
```{r}
plot(data$Wind, data$Ozone,pch=16)
mod <- lm(data$Ozone~data$Wind)
summary(mod)
abline(mod,col="red",lty=2)
```




# 3. Report Writing

##The R scripting language


* A script is a series of instructions that when executed sequentially automates a task
    + A script is a good solution to a repetitive problem
* The art of good script writing is
    + understanding exactly what you want to do
    + expressing the steps as concisely as possible
    + making use of error checking
    + including descriptive comments
* R is a powerful scripting language, and embodies aspects found in most standard programming environments
    + procedrual statements
    + loops
    + functions
    + conditional branching
* Scripts may be written in any standard text editor, e.g. notepad, gedit, kate
    + we will use RStudio

## Principles of Reproducible Research

![step-two](images/SidneyHarris_MiracleWeb.jpg)

Sidney Harris - New York Times

## Why should we do reproducible research?

Five selfish reasons - [Florian Markowetz Blog](https://scientificbsides.wordpress.com/2015/07/15/five-selfish-reasons-for-working-reproducibly/) and [slides](http://f1000research.com/slides/4-207)

1. Avoid disaster
2. Easier to write papers
3. Easier to talk to reviewers
4. Continuity of your work in the lab
5. Reputation


##It is a hot topic at the moment

- Statisticians at MD Anderson tried to reproduce results from a Duke paper and unintentionally unravelled a web of incompetence and skullduggery
    + as reported in the ***New York Times***
    
![nyt-article](images/rep-research-nyt.png)

##Hear the full account

- Very entertaining talk from Keith Baggerly in Cambridge 2010

<iframe width="560" height="315" src="https://www.youtube.com/embed/7gYIs7uYbMo" frameborder="0" allowfullscreen></iframe>


##What can we do about it?

- Use scripts / R
- Use version control
- Document early
- Document everything
- Write comments and explanations
- Automatically-generate your plots, tables, etc from the data
    + always ensure that you have the latest version

##Simple example in RStudio
- Lets take Day_1_scripts/1.3_NBcountData.R
    + an analysis of a RNA-seq dataset using edgeR
- Use the Compile Notebook button in RStudio
- Take an R script and turn into HTML, PDF or even Word
- All code will be displayed and the outputs printed
- A compiled report will be generated in your working directory

![compile](images/RStudio-menu.png)



## What is going on?

- The `knitr` package is being used convert the R script into 'markdown' format, which it then compiles into the output of your choosing
- `knitr` is distributed with RStudio
    + `knitr` is the modern-day equivalent of `Sweave`
- markdown is a easy-to-read, easy-to-write text format often used to write HTML, readme files etc
- the following should create the file `rna-seq.Rmd` in your working directory

```{r eval=FALSE}
library(knitr)
spin(hair="Day_1_scripts/1.3_NBcountData.R",knit=FALSE)
```

## Not quite enough for a reproducible document

- Minimally, you should record what version of R, and the packages you used.
- use the `sessionInfo()` function
    + e.g. for the version of R I used to make the slides
```{r}
sessionInfo()
```

- Lets add this to the R scripts and see what happens


## Defining chunks

- It is not great practice to have one long, continuous R script
- Better to break-up into smaller pieces; '*chunks*'
- You can document each chunk separately
- Easier to catch errors
- The characteristics of each chunk can be modified
    + You might not want to print the R code for each chunk
    + or the output
    + etc

## Create a markdown file from scratch

File - > New File - > R Markdown

- Choose 'Document' and the default output type (HTML)
- A new tab is created in RStudio
- The header also you to specify a Page title, author and output type
```{r eval=FALSE}
---
title: "Untitled"
author: "Mark Dunning"
date: "16/06/2015"
output: html_document
---
```

## Format of the file

- **Lines 8 - 10** Plain text description
- **Lines 12 - 14** An R code 'chunk'
- **Lines 18 to 20** Another code chunk, this time producing a plot

![md-format](images/markdown-format.png)

- Pressing the ***Knit HTML*** button will create the report
    + Note that you need to 'save' the markdown file before you will see the compiled report in your working directory
    
##Text formatting
See ***Markdown Quick Reference*** in RStudio

- enclose text in \* to format in *italics*
- enclose text in \*\* to format in **bold**
- \*\*\* for ***bold italics***
- \` to format like `code`
- \$ to include equations: $e =mc^2$
- \> quoted text: 

>To be or not to be

- see Markdown Quick Reference for more 
    + adding images
    + adding web links
    + tables

## Chunk options

- It's a good idea to name each chunk
    + Easier to track-down errors
- We can display R code, but not run it
    + `eval=FALSE`
- We can run R code, but not display it
    + `echo=FALSE`
    + e.g. setting display options
- Suppress warning messages
    + `warning=FALSE`

    
## Chunk options: eval

- Sometimes we want to format code for display, but not execute
    + we want to show the code for how we read our data, but want our report to compile quickly

```
'''{r,eval=FALSE}
data <- read.delim("path.to.my.file")
'''
```


## Chunk options: echo

- might want to load some data from disk
    + e.g. the R object from reading the data in the previous slide
- your P.I. wants to see your results, but doesn't really want to know about the R code that you used
```
'''{r echo=FALSE}
load("mydata.rda")
'''
```

## Chunk options: results

- Some code or functions might produce lots of output to the screen that we don't need
```{r results='hide'}
for(i in 1:100){
  print(i)
}
```

##Chunk options: message and warning

- Loading an R package will sometimes print messages and / or warnings to the screen
    + not always helpful in a report
```
'''{r}
library(DESeq)
'''
```

```{r echo=FALSE}
library(DESeq)
```

##Chunk options: message and warning

- Using `message=FALSE` and `warning=FALSE`
```
'''{r message=FALSE,warning=FALSE}
library(DESeq)
'''
```
- Could also need `suppressPackageStartupMessages`

##Chunk options: cache

- `cache=TRUE` will stop certain chunks from being evaluate if their code does not change
- speeds-up the compilation of the document
    + we don't want to reload our dataset if we've only made a tiny change downstream
```
'''{r echo=FALSE,cache=TRUE}
load("mydata.rda")
'''
```

## Including plots

- Use a plotting function (`plot`, `boxplot`, `hist` etc) will include the plot at the relevant point in the document
```
'''{r}
plot(1:10, jitter(1:10))
'''
```

```{r echo=FALSE}
plot(1:10, runif(10))
```

## Control over plots

```
'''{r fig.height=2,fig.align='right', fig.height=4,fig.width=9}
plot(1:10, jitter(1:10))
'''
```

```{r echo=FALSE,fig.height=3,fig.align='right', fig.height=4,fig.width=9}
plot(1:10, runif(10))
```


## Running R code from the main text

- We can add R code to our main text, which gets evaluated
    + make sure we always have the latest figures, p-values etc

```
.....the sample population consisted of  'r table(gender)[1]' females and 'r table(gender)[2]' males.....
```

```{r echo=FALSE}
gender <- c(rep("F", 47), rep("M", 50))
```
.....the sample population consisted of  `r table(gender)[1]` females and `r table(gender)[2]` males.....



```
.....the p-value of the t-test is 'r pval', which indicates that.....
```
```{r echo=FALSE}
pval <- 0.05
```
.....the p-value of the t-test is `r pval`, which indicates that.....

## Running R code from the main text

- Like the rest of our report these R statements will get updated each time we compile the report

```
.....the sample population consisted of  'r table(gender)[1]' females and 'r table(gender)[2]' males.....
```

```{r echo=FALSE}
gender <- c(rep("F", 41), rep("M", 54))
```
.....the sample population consisted of  `r table(gender)[1]` females and `r table(gender)[2]` males.....



```
.....the p-value of the t-test is 'r pval', which indicates that.....
```
```{r echo=FALSE}
pval <- 0.1
```
.....the p-value of the t-test is `r pval`, which indicates that.....



## Conditional output

```{r}
pval <- 0.1
```


```
.....The statistical test was 'r ifelse(pval < 0.05, "", "not")' significant....
```



The statistical test was `r ifelse(pval < 0.05, "", "not")` significant

```{r}
pval <- 0.01
```


```
.....The statistical test was 'r ifelse(pval < 0.05, "", "not")' significant....
```


The statistical test was `r ifelse(pval < 0.05, "", "not")` significant


## Printing vectors
```
The months of the year are 'r month.name'
```

The months of the year are `r month.name`

## References

- Useful reference:
    +  Reproducible Research in R and RStudio
        + http://christophergandrud.github.io/RepResR-RStudio/
        + Useful exercise is to compile the book from the [source code](https://github.com/christophergandrud/Rep-Res-Book)
    + [Implementing Reproducible Research](https://osf.io/s9tya/wiki/home/)


## Exercise

- Create a new markdown file that will report your analysis of the NB count data
    + File -> New File -> R Markdown
- Create separate code chunks for each stage of the analysis (copy code from Day_1_scripts/1.3_NBcountData.R if you wish)
    + Reading the data
    + Basic Statistics
    + Reorder table by decreasing nuclei count
    + Identify patients with >33% NB amplification
    + Write out results table as comma separated values file
    
## Exercise

- Once you have a report that you are happy with
- Use in-line R code to report how many patients have > 33% amplifications
- A new dataset is acquired with 100 observations, futhermore we now want to identify patients with 30% amplifications
    + 'updated-NBcountData.txt'
- Modify your report so that it can read the new data and use the new criteria


# 4. Data Manipulation Techniques

##Introducing loops

- Many programming languages have ways of doing the same thing many times, perhaps changing some variable each time. This is called *looping*
- Loops are not used in R so often, because we can usually achieve the same thing using vector calculations
- For example, to add two vectors together, we do not need to add each pair of elements one by one, we can just add the vectors
```{r eval=FALSE}
x<- 1:10
y <- 11:20
x+y
```
- But there are some situations where R functions can not take vectors as input. For example, `read.csv` will only load one file at a time
- What if we had ten files to load in, all ending in the same extension (like `.csv`)?

##Introducing loops
- We could do this:

```{r eval=FALSE}
colony  <-data.frame() # Start with empty data frame
colony1 <- read.csv("11_CFA_Run1Counts.csv")
colony2 <- read.csv("11_CFA_Run2Counts.csv")
colony3 <- read.csv("11_CFA_Run3Counts.csv")
  ...
colony10 <- read.csv("11_CFA_Run10Counts.csv")
colony <- rbind(colony1, colony2, colony3, ..., colony10)
```
- But this will be boring to type, difficult to change, and prone to error
- As we are doing the same thing 10 times, but with a different file name each time, we can use a **loop** instead

##Loops: Commands and flow control
- R has two basic types of loop
    + a `for` loop: run some code on every value in a vector
    + a `while` loop: run some code while some condition is true
    
`for` 
```{r loops1, eval=FALSE}
for(i in 1:10){
  print(i)
}
```
`while`
```{r  eval=FALSE}
i <- 1
while ( i <= 10 ) {
   print(i)
   i <- i + 1
}
```

##Loops: Commands and flow control

- Here's how we might use a `for` loop to load in our CSV files
- If the data files are in your current working directory, we can look up files
containing a particular substring in their name using the `dir` function



```{r eval=FALSE}
dir(pattern="Counts.csv")
```

```{r echo=FALSE}
dir("Day_1_scripts/",pattern="Counts.csv")

```

- So we can load all the files using a `for` loop as follows

```{r loops2, eval=FALSE}
colony <- data.frame()
countfiles <- dir(pattern="Counts.csv")
for (file in countfiles) {
   t <- read.csv(file)
   colony <- rbind(colony, t)
}
```

- Here, we use a temporary variable `t` to store the data in each file, and then add that data to the main `colony` data frame.

##Conditional branching: Commands and flow control

- Use an `if` statement for any kind of condition testing
- Different outcomes can be selected based on a condition within brackets

```{r if, eval=FALSE}
if (condition) {
... do this ...
} else {
... do something else ...
}

```

- `condition` is any logical value, and can contain multiple conditions. 
    + e.g. `(a == 2 & b < 5)`, this is a compound conditional argument

##Conditional branching: Commands and flow control
- For example, if we were writing a script to load an unknown set of files, using the `for` loop we wrote before, we might want to warn the user if we can't find any files with the pattern we are searching for. Here's how we can use an `if` statement to test for this

```{r flow-control,eval=FALSE}
colony <- data.frame()
countfiles <- dir(pattern="Counts.csv")
if (length(countfiles) == 0) {
    stop("No Counts.csv files found!")
} else {
    for (file in countfiles) {
        t <- read.csv(file)
        colony <- rbind(colony, t)
    }
}

```

- The `stop` function outputs the error message and quits


##Code formatting avoids bugs!
Compare:
```{r eval=FALSE}
f -26
while(f!=0){
print(letters[f])
f <- f-1}
```
to:
```{r eval=FALSE}
f <- 26
while( f != 0 ){
   print(letters[f])
   f <- f-1
}
```
- The code between brackets `{}` *always* is *indented*, this clearly separates what is executed once, and what is run multiple times
- Trailing bracket `}` always alone on the line at the same indentation level as the initial bracket `{`
- Use white spaces to divide the horizontal space between units of your code, e.g. around assignments, comparisons

##Exercise


- Load in the `colony` data frame using a `for` loop. Three of the data files are in the `Day_1_scripts` folder. Load all three files into `colony` using the for loop in the slides
- How many observations do you have in the colony data frame? Find out by counting the number of rows in `colony` using the `nrow` function
- Suppose a power analysis of your data shows that you only need 48 observations to robustly test your hypothesis. This means we can stop loading files when we have loaded at least 48 observations. Modify your `for` loop so it will only load files if the `colony` data frame has less than 48 observations in it

##Answers to Exercise

- To order the patients by decreasing age
```{r ex3ans1,eval=FALSE}
patients[rev(order(patients$Age)),]
```
- To find the number of rows in the colony data frame
```{r ex3ans2,eval=FALSE}
nrow(colony)
```

- To stop loading files after at least 48 observations have been found, use the code from the first `for` loop slide with a new `if` statement

```{r ex3ans4, eval=FALSE}
colony <- data.frame()
countfiles <- dir(pattern="Counts.csv")
for (file in countfiles) {
    if (nrow(colony) < 48 ) {
        t <- read.csv(file)
        colony <- rbind(colony, t)
    }
}
```



# 5. Data analysis report example

## Combining data from multiple sources: *Gene Clustering Example*

* R has powerful functions to combine heterogeneous data into a single data set
* Gene clustering example data
    + five sets of differentially expressed genes from various experimental conditions
    + file with names of experimentally-verified genes
* Gene clustering exercise
    + combine this dataset into a single table and cluster to see which conditions are similar
    + repeat the clustering but only on a subset of experimentally-verified genes
    
## Combining gene tables

* input files have two columns: gene names and fold change
* we want to combine all five tables into a single table, with 0 for missing values
![gene-tables](images/gene-tables.png)

## Gene Clustering: Script Walkthrough 1

* To make the big table we first need to find out all the genes present in at least one of the files
* Make sure not to use factors in `read.delim()`
    + when loading in character data, use `as.is=TRUE` to prevent it being converted to factors
    + `union()` is a set operation which combines two vectors by eliminating duplicates. See also `intersect` and `setdiff`

```{r eval=FALSE}
#start with an empty collection of genes
genes <- c()
for(fileNum in 1:5){
  #load in files 2_3.DiffGenes1.tsv...
  t <- read.delim(paste("2.3_DiffGenes", fileNum, ".tsv"
                        , sep="")
                  , as.is=TRUE, header=FALSE)
  #label the input columns to help code readability
  names(t) <- c("gene", "expression")
  genes <- union(genes, t$gene)
}
#for tidiness order our genes by name
genes <- sort(genes)
genes #show all genes
```
- *Example code: 2.3_geneClustering.R*

## Gene Clustering: Script Walkthrough 2

* Using the complete list of genes, we can create the big table and fill in the values:
    + `match()` returns the index of the first argument in the second. i.e. index of input file genes in the big table
    + we use index to pick the rows in such way that they match the order in the input file
    
```{r eval=FALSE}
#make the destination table [rows=unique genes,cols=file numbers]
values <- matrix(0, nrow=length(genes), ncol=5)
rownames(values) <- genes
for(fileNum in 1:5){
  #read in the file again
    t <- read.delim(paste("2.3_DiffGenes", fileNum,".tsv"
                        , sep=""), as.is=TRUE, header=FALSE)
    names(t) <- c("gene","expression")
    index <- match(t$gene, rownames(values))
    values[index,fileNum] <- t$expression
}
```

## Gene Clustering: Script Walkthrough 3

* Now we can do hierarchical clustering:
    + Values from the matrix are colour-coded. Rows and columns are re-arranged according to similarity

```{r eval=FALSE,fig.height=4}
heatmap(values, scale="none", col=cm.colors(256))
```

```{r echo=FALSE}
setwd("Day_2_scripts/")
genes <- c()
for(fileNum in 1:5){
  t <- read.delim(paste("2.3_DiffGenes", fileNum, ".tsv"
                        , sep="")
                  , as.is=TRUE, header=FALSE)
  names(t) <- c("gene", "expression")
  genes <- union(genes, t$gene)
}
genes <- sort(genes)
values <- matrix(0, nrow=length(genes), ncol=5)
rownames(values) <- genes
for(fileNum in 1:5){
    t <- read.delim(paste("2.3_DiffGenes", fileNum, ".tsv"
                        , sep=""), as.is=TRUE, header=FALSE)
    names(t) <- c("gene", "expression")
    index <- match(t$gene, rownames(values))
    values[index, fileNum] <- t$expression
}
heatmap(values, scale="none", col=cm.colors(256))

```

## Gene Clustering: Script Walkthrough 4 

* In a second part of our analysis, we want to produce the same heatmap but only based on a list of experimentally-verified genes
* The problem is that the data are not formatted in the most convenient way:

![gene-lists](images/gene-lists.png)


## Gene Clustering: Script Walkthrough 5

* We load in this table, and only extract the gene names, then we use them to select a subset of the `values` matrix
```{r eval=FALSE}
t.exp <- read.delim("2.3_ExperimentalGenes.tsv",
                    as.is=TRUE)
experim.genes <- unlist(strsplit(t.exp$genes, ","))
```
* `unlist` flattens out a nested list into a single vector
* `strsplit` splits a vector of strings by a custom split character (`,`). The result is a list of split values for each element of the input vector
* Now, redo the heatmap by using just the genes in the experimentally verified set  
```{r eval=FALSE}
is.experimental <- rownames(values) %in% experim.genes
heatmap(values[is.experimental,], scale="none"
        , col=cm.colors(256))
```

## Gene Clustering Review

* We load the five tables twice; first to collect gene names, then to load expression values
* Based on the expression table (`values`) we construct a clustered heatmap first on the whole set of genes, then on a selected subset
* Go through the code, try it out and understand it
* Try answering the following questions
    + what is `rownames(values)`
    + why is `rownames(values)[index]` and `t$gene` giving the same output?
    + what is the difference between `rownames(values) %in% experim.genes` and `experim.genes %in% rownames(values)`
  

#References

##References
* Official documentation on:
    + http://cran.r-project.org/manuals.html
* A good repository of R recipes
    + Quick-R: http://www.statmethods.net/
* Don't forget that many packages come with tutorials (vignettes)
* R forums
    + http://stackoverflow.com/questions/tagged/r
    + http://news.gmane.org/gmane.comp.lang.r.general
    
* Plenty of textbooks to choose from, comprehensive list + reviews
    + http://www.r-project.org/doc/bib/R-books.html

#End of Course

##Thanks for your attention

- Please fill-in your feedback so we can improve the course
- The key to learning R is practice, practice, practice!
    + If you don't have your own data yet, look online
    + http://vincentarelbundock.github.io/Rdatasets/datasets.html
- Meet with fellow R users
    + http://www.meetup.com/Cambridge-R-Users-Group-Meetup/
    + informal, quarterly talks
- Look out for an 'Intermediate R' course    

    
